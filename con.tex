\documentclass[17pt]{article}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{amsthm, amsmath, amssymb}
\usepackage{tikz}
\usepackage[margin=2cm]{geometry}

\begin{document}

\section{Многопоточное исполнение}

\emph{Процессом исполнения} называется последовательный запуск инструкций, который в любой момент может быть прерван планировщиком системы и возобновлён через некоторое время. За данный промежуток состояние системы может кардинально измениться в пределах используемых функций. Единственным способом сделать какое-либо действие \emph{атомарно} - использовать специальные инструкции процессора, которые в большинстве языков программирования сведены в отдельный тип и называются \emph{atomic}.

Так или иначе ядро ОС предоставляет системные вызовы, которые предоставляют \emph{блокирующий} механизм синхронизации - \emph{mutex}. Он универсален и достаточно быстр и оптимален, если речь идёт об использовании других системных вызовов в этом же блоке кода. Но если заглянуть глубже в те механизмы, которые мы используем для обработки запросов, то оказывается, что его скорости мягко говоря недостаточно. В зависимости от того, какие механизмы синхронизации мы используем, появляется 4 основных вида гарантий работы приложения:
\begin{itemize}
	\item Блокирующие
	\begin{itemize}
		\item \textsc{locked} - мы верим, что программа завершится когда-нибудь, но мы не можем гарантировать, что система будет выполнять какие-либо действия, если каким-либо потокам будет дано управление
		\begin{lstlisting}[language=C++]
int memory = 0;
std::mutex lock_mutex;
int fetch_add() {
	std::lock_guard<std::mutex> lock(lock_mutex); // mutex.lock();
	int cur_memory = memory++;
	// ~lock_guard<std::mutex>(lock)              // mutex.unlock();
	return cur_memory;
}
		\end{lstlisting}

		\item \textsc{obstruction-free} - мы гарантируем, что система будет продвигаться, если на пути одного потока не будет встречено никаких других. Иначе гарантии нет
		\begin{lstlisting}[language=C++]
int memory = 0;
std::atomic<bool> spin_lock{false};
int fetch_add() {
    bool expected = false;
    while (spin_lock.compare_exchange_weak(expected, true))
		std::this_thread::yield();
    int cur_memory = memory++;
    spin_lock.store(false);
    return cur_memory;
}
		\end{lstlisting}
	
	\end{itemize}
	\item Неблокирующие
	\begin{itemize}

		\item \textsc{lock-free} - мы гарантируем, что в целом система будет продвигаться в каждый момент времени, но нет гарантии, что та или иная операция будет завершена за конечное число шагов
		\begin{lstlisting}[language=C++]
std::atomic<int> memory{0};
int fetch_add() {
	int cur_memory = memory.load();
	while (!memory.compare_exchange_weak(cur_memory, cur_memory + 1)) {
		cur_memory = memory.load();
	}
	return cur_memory;
}
		\end{lstlisting}

		\item \textsc{wait-free} - самая сильная гарантия, мы уверены в том, что каждая операция будет завершена за конечное число шагов
		\begin{lstlisting}[language=C++]
std::atomic<int> memory{0};
int fetch_add() {
	return memory.fetch_add(1);
}
		\end{lstlisting}
	
	\end{itemize}
\end{itemize}
В дальнейшем мы будем прибегать в общим приемам, которые эти гарантии предоставляют.

\section{Особенности работы с памятью}

У каждого потока есть своя локальная память, которую он может менять без опасений изменения другими потоками. Также у него есть доступ к общей памяти. Чтобы понять какие проблемы могут возникнуть при её изменении давайте представим следующие программы:

\begin{minipage}{0.5\textwidth}
\begin{lstlisting}[language=C++]
Object *ref;
void first() {
	ref = new Object(A);
	// the thread has stopped
	if (ref != nullptr) {
		// do smth with A
	}
}
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.5\textwidth}
\begin{lstlisting}[language=C++]
void second() {
	if (ref != nullptr) delete ref;
	ref = new Object(B);
}
\end{lstlisting}
\end{minipage}

Решением подобного рода проблем, связанных с удалением данных, является применение SMR(safe memory reclamation) алгоритмов (либо сборщика мусора для некоторых языков). Суть их очень проста - они сначала дожидаются завершения всех потоков, имеющих ссылку на удаляемый объект, и лишь затем осуществляют освобождение. Мы рассмотрим два из них, для начала поговорим о счётчике ссылок

\section{Счётчик ссылок}

Первое решение, приходящее в голову - аккуратно подсчитывать количество ссылающихся на объект потоков, чтобы при достижении нуля начать освобождение. Давайте реализуем \textsc{mutex-based} подход

\begin{lstlisting}[language=C++]
using ull = unsigned long long;
class ReferenceCounter {
	ull counter = 1;
	std::mutex lock_mutex;
public:
	bool increment() {
		std::lock_guard<std::mutex> lock(lock_mutex);
		if (counter != 0) {
			++counter;
			return true;
		}
		return false;
	}
	bool decrement() {
		std::lock_guard<std::mutex> lock(lock_mutex);
		if ((--counter) == 0) {
			return true;
		}
		return false;
	}
	ull get_counter() {
		std::lock_guard<std::mutex> lock(lock_mutex);
		return counter;
	}
};
\end{lstlisting}

Давайте его немного ускорим и превратим в lock-free

\begin{lstlisting}[language=c++]
using ull = unsigned long long;
class ReferenceCounter {
	std::atomic<ull> counter = 1;
public:
	bool increment() {
		ull cur_counter = counter.load();
		while (cur_counter != 0 &&
	!counter.compare_exchange_weak(cur_counter, cur_counter + 1)) {
			cur_counter = counter.load();
		}
		return cur_counter != 0;
	}
	bool decrement() {
		return counter.fetch_sub(1) == 1;
	}
	ull get_counter() {
		return counter.load();
	}
};
\end{lstlisting}

Заметим, что наше состояние всегда определено и на написание каждой операции мы не меняем функции. Но что здесь

\begin{lstlisting}[language=c++]
using ull = unsigned long long;
class ReferenceCounter {
	std::atomic<ull> counter = 1;
	const ull zero_flag = (1ll << 63);
public:
	bool increment() {
		if (counter.fetch_add(1) & zero_flag) {
			return false;
		}
		return true;
	}
	bool decrement() {
		if (counter.fetch_sub(1) == 1) {
			ull expected = 0;
			if (counter.compare_exchange_strong(expected, zero_flag)) {
				return true;
			}
		}
		return false;
	}
	ull get_counter() {
		// why not just:
		ull cur_counter = counter.load();
		if (cur_counter & zero_flag) return 0;
		if (cur_counter == 0) return 1;
		return cur_counter;
		// give an example of situation when it doesn't work
	}
};
\end{lstlisting}

Мы можем представить, что операция \emph{increment} будет вызвана после \emph{fetch\_sub(1)}, но до \emph{compare\_exchange}. Тогда состояние счетчика будет 0 и операция прибавления 1, будучи реально вызванной после \emph{decrement}, изменит состоянее до неё, то есть по сути будет исполнена раньше. Нам необходимо будет определить что вообще значит порядок операций в терминах параллельного программирования, но для начала поговорим о простейшем применении данного счётчика 

\subsection{Механизм COW для строк}

Допустим мы хотим научиться сжимать создаваемую при копировании строк информацию, чего с помощью COW делать не стоит (более того его из-за некоторых причин удалили для строк в 11-ом стандарте C++). Тогда вместо обычного \emph{basic\_string} вида

\begin{lstlisting}[language=c++]
class basic_string {
	size_t size;
	char  *c_str;
public:
	basic_string(const basic_string &other) {
		size = other.size;
		c_str = new char[size];
		memcpy(c_str, other.c_str, size);
	}
};
\end{lstlisting}
Будем при копировании лишь ссылаться на тот же \emph{c\_str}, не переписывая заново его содержимое. Если при изменении мы являемся исключительным владельцем данной строки, то тогда мы действительно поменяем данные. Иначе мы скопируем строку, как мы и хотели до этого

\begin{lstlisting}[language=c++]
class basic_string {
	size_t size;
	char  *c_str;
	ReferenceCounter *counter;
public:
	basic_string(const basic_string &other) {
		if (!other.counter->increment())
			throw std::invalid_argument("");
		size = other.size;
		c_str = other.c_str;
		counter = other.counter;
	}
	char& operator[](size_t index) {
		if (counter->get_counter() > 1) {
			char *new_c_str = new char[size];
			memcpy(new_c_str, c_str, size);
			if (counter->decrement()) {
				delete c_str;
			}
			c_str = new_c_str;
			counter = new ReferenceCounter();
		}
		return c_str[index];
	}
	~basic_string() {
		if (counter->decrement()) {
			delete c_str;
			delete counter;
		}
	}
};
\end{lstlisting}


\section{Линеаризуемость}
\begin{tikzpicture}[scale=0.8]
\draw[->] (0,0) -- (10,0);
\draw (1.5,0.5) rectangle (2.5,1.0) node[midway] {enqueue};
\draw (3.5,1) rectangle (1.5,1.5) node[midway] {dequeue};
\draw (6,0.5) rectangle (8,1.0) node[midway] {enqueue};
\end{tikzpicture}
\section{Lock-free очередь майкла-скотта}
\section{Несимметричный RCU}

\end{document}
